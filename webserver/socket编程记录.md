## 套接字的文件描述符
类型	              代表	            用途	             生命周期
服务器套接字描述符	m_server_fd	    监听客户端连接请求	       与服务器进程相同
客户端连接描述符	client_fd	    与特定客户端进行数据通信    仅在连接期间有效
## epoll（不参与I/O，只通知）
*** 底层实现机制 ***
1. 底层实现机制：
    红黑树 + 双向链表： 
    内核使用红黑树来存储所有被监控的文件描述符，提供O(log n)的查找效率
    使用双向链表存储就绪的事件，避免每次遍历所有文件描述符
2. 事件驱动机制：
    当文件描述符状态发生变化时，内核会主动通知epoll，而不是被动轮询
    每个文件描述符都注册了一个回调函数，当事件就绪时会将该fd加入就绪链表
3. 一些函数和变量
   events数组：epoll_event数组，用于保存就绪的文件描述符和事件类型，只是数据缓冲区
   epoll_wait函数：epoll_wait函数用于等待就绪的文件描述符，返回就绪的文件描述符列表
   内核检查 m_epoll_fd 对应的 epoll 实例,查看哪些之前添加到 epoll 中的 fd 现在有事件就绪,将这些就绪事件复制到 events 数组中
4. 一些epoll状态
   EPOLLIN：表示对应的文件描述符可以读
   EPOLLOUT：表示对应的文件描述符可以写
   EPOLLET：表示使用边缘触发模式
   EPOLLPRI：表示对应的文件描述符有紧急数据可读
   EPOLLERR：表示对应的文件描述符发生错误
   EPOLLHUP：表示对应的文件描述符挂断
   EPOLLRDHUP：表示对应的文件描述符的读端已关闭
   EPOLLONESHOT：表示只处理一次事件，当处理完一个事件后，该文件描述符不再触发该事件,就是epoll_wait获取到这个fd后，会禁用这个fd，即只有一个线程能获取该事件
*** 工作流程 ***
I/O多路复用允许一个进程或线程同时监控多个文件描述符。它的工作流程如下：
1. 注册阶段：将需要监控的文件描述符注册到多路复用器（如epoll）
2. 等待阶段：调用多路复用函数（如epoll_wait）等待事件
3. 事件处理：当有文件描述符就绪时，多路复用器返回就绪的文件描述符列表
4. 处理就绪的I/O：对每个就绪的文件描述符进行相应的I/O操作
5. 多路复用的含义：多路复用指的是可以让线程同时监控多个文件描述符，当其中任意一个文件描述符就绪时，就可以进行相应的I/O操作。
6. 处理模式：水平和边缘触发
    水平触发（Level Triggered, LT）：
        当文件描述符就绪时，epoll会通知应用程序，应用程序可以立即处理I/O操作
        只要文件描述符处于就绪状态，就会持续收到事件通知
    边缘触发（Edge Triggered, ET）：
        当文件描述符状态发生变化时，epoll会通知应用程序，应用程序只需要处理新增的数据
        状态改变时只通知一次，不管数据是否处理完毕

一些疑惑的问题：
1. 服务器的socket只是算一个事件吗，那每次客户端来一个get/post请求，是算什么，一个新事件，还是说仍然是这个事件，只不过从阻塞变成就绪​？
   服务器socket作为一个事件：
    服务器socket（监听socket）确实只注册了一个epoll事件，用于监听新连接
    当有新的客户端连接请求时，这个监听socket会变为就绪状态，触发EPOLLIN事件
    客户端连接和请求处理：
    
    当客户端发起连接时，服务器socket变为就绪状态，epoll_wait会返回
    此时调用accept()获取新的客户端socket（代表一个具体的连接）
    这个新获取的客户端socket会被添加到epoll中作为一个独立的事件
    GET/POST请求的处理：

    每个客户端连接（每个客户端socket）是一个独立的事件
    当客户端发送GET/POST请求时，对应的客户端socket会变为就绪状态（有数据可读）
    在下一次epoll_wait中，这个客户端socket的事件会被触发
    所以每个客户端连接是一个单独的事件，而不是复用服务器监听事件
    事件状态变化：

    不是"从阻塞变成就绪"，而是socket上有数据可读/可写时，epoll检测到这种状态变化
    在边缘触发（ET）模式下，只有状态发生变化时才会通知一次
    在水平触发（LT）模式下，只要处于就绪状态就会持续通知
    所以总结来说：

    服务器监听socket：负责接收新的连接请求
    每个客户端连接：作为一个独立的socket事件，处理该客户端的具体请求（GET/POST等）
## signal的用法
signal 函数是 C/C++ 中用于设置信号处理函数的标准库函数，位于 <signal.h> 头文件中。它允许程序捕获和处理来自操作系统或用户的各种信号。
## socket bind和std::bind
    soctet bind  套接字绑定
    std::bind 是 C++11 标准库中的一个函数，用于将函数对象或函数指针绑定到一个对象或函数，并返回一个函数对象。
## invoc
``` c++
    struct iovec {
    void  *iov_base;    // 指向数据缓冲区的起始地址 (Starting address)
    size_t iov_len;     // 该缓冲区的长度 (Number of bytes to transfer)
    };
```