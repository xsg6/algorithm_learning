C++11 及后续版本核心新特性介绍

C++11 是 C++ 语言的一次重大革新，引入了大量现代化特性，极大提升了代码简洁性、安全性和开发效率。后续的 C++14、C++17、C++20 等版本在此基础上持续优化补充，进一步完善了语言生态。以下是各版本核心新特性的详细介绍，重点涵盖实际开发（如 ROS2）中高频使用的功能。

一、C++11 核心新特性（奠定现代化基础）

1.1 类型推导与简化声明

1.1.1 auto 关键字

核心作用：让编译器自动推导变量类型，简化复杂类型声明，提升代码可读性。

适用场景：

- 基础类型推导：无需显式声明 int、float 等，编译器根据初始化值自动判断。

- 复合类型推导：适配指针、引用、STL 容器迭代器等复杂类型，避免冗长书写。

- 函数返回值推导（C++14 扩展）：允许函数返回值用 auto 声明，编译器自动推导返回类型。

// 基础类型推导
auto x = 100;          // 推导为 int
auto y = 3.14f;        // 推导为 float
auto str = "hello";    // 推导为 const char*

// 复合类型推导（引用需显式标注 &）
int a = 200;
auto& ref = a;         // 推导为 int&（引用类型）

// STL 容器迭代器推导（常用）
std::vector<int> vec = {1, 2, 3};
auto it = vec.begin(); // 推导为 std::vector<int>::iterator

// 函数返回值推导（C++14）
auto sum(int a, int b) { return a + b; } // 推导返回值为 int

1.1.2 decltype 关键字

核心作用：获取表达式的类型，不执行表达式，常用于模板编程或需要复用类型的场景。

int num = 10;
decltype(num) b = 20; // b 的类型为 int，与 num 一致

// 结合 auto 用于模板函数返回值推导（C++11 模板返回值推导方案）
template <typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b; // 返回值类型为 a + b 的结果类型
}

1.2 匿名函数（Lambda 表达式）

核心作用：就地定义、就地使用的匿名函数，无需单独声明函数名，简化回调函数、算法参数等场景的代码。

基本结构：[capture](parameters) mutable -> return_type { 函数体; }

各部分说明：

- [capture]：捕获列表（必选），控制外部变量能否在函数体内使用，是 Lambda 的核心特性。

- (parameters)：参数列表（可选），与普通函数参数规则一致。

- mutable：可选，允许修改按值捕获的变量（默认按值捕获的变量为 const 不可修改）。

- -> return_type：返回值类型（可选），编译器可自动推导，复杂场景需显式指定。

- {}：函数体（必选），存放执行逻辑。

核心捕获方式：

- []：空捕获，不捕获任何外部变量。

- [x, y]：按值捕获变量 x、y，函数体内使用的是副本，修改不影响外部原变量。

- [&x, &y]：按引用捕获变量 x、y，函数体内修改会直接影响外部原变量。

- [=]：按值捕获所有外部变量，简化多变量捕获场景。

- [&]：按引用捕获所有外部变量，适合需要修改多个外部变量的场景。

// 示例 1：简单 Lambda 表达式（无参数、无捕获）
auto add = [](int a, int b) { return a + b; };
int result = add(3, 5); // result = 8

// 示例 2：按引用捕获外部变量
int total = 0;
auto accumulate = [&total](int num) { total += num; };
accumulate(10);
accumulate(20);
std::cout << total; // 输出 30

// 示例 3：结合 STL 算法（排序）
std::vector<int> vec = {3, 1, 4, 1, 5};
std::sort(vec.begin(), vec.end(), [](int a, int b) {
    return a < b; // 升序排序，Lambda 作为比较函数参数
});

1.3 智能指针（内存管理革新）

核心作用：自动管理堆内存生命周期，避免内存泄漏、野指针、重复释放等经典问题。智能指针本身存储在栈上，指向堆内存资源，离开作用域时自动调用析构函数释放资源。需包含头文件 #include<memory>。

三种核心智能指针：

1.3.1 unique_ptr（独占式智能指针）

特性：独占式拥有资源，同一时间仅允许一个 unique_ptr 指向某一资源，不可拷贝，仅可移动（通过 std::move 转移所有权）。

// 创建 unique_ptr（推荐用 std::make_unique，C++14 引入）
auto ptr = std::make_unique<int>(10); // 指向堆上的 int(10)

// 转移所有权（原 ptr 变为空指针）
auto ptr2 = std::move(ptr);

// 无需手动释放，离开作用域自动销毁

1.3.2 shared_ptr（共享式智能指针）

特性：共享式拥有资源，通过引用计数管理资源生命周期，多个 shared_ptr 可指向同一资源，引用计数为 0 时自动释放资源。

// 创建 shared_ptr（推荐用 std::make_shared，效率更高）
auto ptr = std::make_shared<std::string>("hello");

// 共享资源，引用计数变为 2
auto ptr2 = ptr;

// 引用计数减 1（ptr 销毁）
ptr.reset();

// 引用计数为 0，资源自动释放（ptr2 销毁时）

1.3.3 weak_ptr（弱引用智能指针）

特性：辅助 shared_ptr 使用，指向 shared_ptr 管理的资源，但不增加引用计数，核心解决 shared_ptr 的循环引用问题。

auto shared_ptr = std::make_shared<int>(100);
std::weak_ptr<int> weak_ptr = shared_ptr; // 不增加引用计数

// 通过 lock() 方法获取 shared_ptr（存在则返回非空）
if (auto ptr = weak_ptr.lock()) {
    std::cout << *ptr; // 输出 100
}

1.4 右值引用与移动语义

核心作用：区分左值（可被取地址的对象）和右值（临时对象、字面量等不可取地址的对象），通过移动语义避免临时对象的拷贝，提升效率；通过完美转发保留参数的左/右值属性。

关键概念：

- 右值引用：用 && 表示，仅能绑定右值。

- 移动构造函数：参数为右值引用，用于将右值的资源“移动”到当前对象，而非拷贝。

- 完美转发：通过 std::forward 实现，在模板函数中保留参数的原始值类别（左值/右值）。

// 移动构造函数示例
class MyString {
private:
    char* data;
    size_t length;
public:
    // 移动构造函数
    MyString(MyString&& other) noexcept {
        data = other.data;       // 直接接管资源
        length = other.length;
        other.data = nullptr;    // 置空原对象，避免重复释放
        other.length = 0;
    }
};

// 完美转发示例
template <typename T>
void forward_func(T&& arg) {
    process_func(std::forward<T>(arg)); // 保留 arg 的左/右值属性
}

1.5 范围 for 循环

核心作用：简化容器/数组的遍历代码，无需手动管理迭代器，语法简洁直观。

// 遍历数组
int arr[] = {1, 2, 3, 4, 5};
for (int num : arr) {
    std::cout << num << " "; // 输出 1 2 3 4 5
}

// 遍历 STL 容器（修改元素需用引用）
std::vector<int> vec = {10, 20, 30};
for (int& num : vec) {
    num *= 2; // 元素翻倍
}
// 遍历结果：20 40 60

二、C++14 核心新特性（优化与补充）

- 扩展 auto 功能：支持函数返回值类型推导，无需显式指定返回值。

- 引入 std::make_unique：补充了 C++11 中 unique_ptr 缺少的工厂函数，推荐用于创建 unique_ptr。

- 泛型 Lambda 表达式：Lambda 的参数可使用 auto 声明，实现类似模板函数的效果。

- 二进制字面量与数字分隔符：支持二进制字面量（前缀 0b），允许用单引号 ' 作为数字分隔符，提升可读性。

// 泛型 Lambda 示例
auto print = [](auto x) { std::cout << x << std::endl; };
print(10);          // 输出 10
print("hello");     // 输出 hello

// 二进制字面量与数字分隔符
int bin = 0b1010'1100; // 二进制 10101100，等价于十进制 172
long long large = 1'000'000'000; // 10 亿，分隔符不影响值

三、C++17 核心新特性（实用性增强）

- 结构化绑定：允许一次性从数组、结构体、tuple 等复合类型中提取多个成员，赋值给多个变量。

- if constexpr：编译期条件判断，根据条件决定是否编译某段代码，提升模板编程效率。

- std::optional：表示一个“可能存在的值”，用于避免使用空指针表示“无值”的场景，提升代码安全性。

- std::variant：类型安全的联合体，可存储多种类型中的一种，避免传统 union 的类型不安全问题。

- 折叠表达式：简化模板参数包的展开，用于处理可变参数模板。

// 结构化绑定示例
std::tuple<int, std::string> get_info() {
    return {1001, "zhangsan"};
}
auto [id, name] = get_info(); // id = 1001，name = "zhangsan"

// if constexpr 示例
template <typename T>
auto get_value(T t) {
    if constexpr (std::is_integral_v<T>) {
        return t * 2; // 整数类型执行此逻辑
    } else {
        return t;     // 其他类型执行此逻辑
    }
}

// std::optional 示例
std::optional<int> find_value(const std::vector<int>& vec, int target) {
    for (int num : vec) {
        if (num == target) return num;
    }
    return std::nullopt; // 无匹配值
}
auto res = find_value({1,2,3}, 2);
if (res.has_value()) {
    std::cout << res.value(); // 输出 2
}

四、C++20 核心新特性（现代化升级）

- 概念（Concepts）：限制模板参数的类型范围，在编译期检查模板参数是否满足要求，替代传统的静态断言，错误信息更清晰。

- 范围（Ranges）：重构 STL 算法，支持链式调用，简化算法组合逻辑，提升代码可读性。

- 协程（Coroutines）：支持异步编程，允许函数在执行过程中暂停并恢复，简化异步代码编写（如网络编程、异步 IO 等场景）。

- 三路比较运算符（<=>）：统一比较操作，自动生成 ==、!=、<、<=、>、>= 等比较运算符，减少重复代码。

// 概念（Concepts）示例
template <typename T>
concept Integral = std::is_integral_v<T>;

// 仅允许整数类型作为参数
template <Integral T>
T add(T a, T b) {
    return a + b;
}

// 三路比较运算符示例
struct Person {
    std::string name;
    int age;
    // 自动生成所有比较运算符
    auto operator<=>(const Person& other) const = default;
};
Person p1{"zhangsan", 20}, p2{"lisi", 25};
if (p1 < p2) { // 按 name 字典序比较，再按 age 比较
    std::cout << p1.name << " is younger";
}

五、新特性在实际开发中的应用（以 ROS2 为例）

C++11 及后续版本的新特性在 ROS2 开发中被广泛应用，主要体现在以下场景：

- 智能指针：ROS2 节点、话题订阅/发布对象等常用 shared_ptr 管理，避免手动释放资源。

- Lambda 表达式：常用于回调函数（如话题回调、服务回调），简化代码结构，避免定义独立回调函数。

- auto 与范围 for 循环：遍历 ROS2 消息、参数列表等场景，简化代码书写。

- std::optional 与 std::variant：处理 ROS2 服务响应、参数获取等“可能失败”的场景，提升代码安全性。

// ROS2 中 Lambda 回调示例
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

class MyNode : public rclcpp::Node {
public:
    MyNode() : Node("my_node") {
        // Lambda 作为话题回调函数
        subscriber_ = this->create_subscription<std_msgs::msg::String>(
            "topic_name",
            10,
            [this](const std_msgs::msg::String::SharedPtr msg) {
                RCLCPP_INFO(this->get_logger(), "Received: %s", msg->data.c_str());
            }
        );
    }
private:
    rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscriber_;
};

六、总结

C++11 及后续版本的新特性围绕“简洁性、安全性、高效性”三大核心目标，从类型推导、内存管理、函数编程、模板优化等多个维度提升了语言能力。在实际开发中，合理运用这些新特性可以大幅减少重复代码、避免常见错误（如内存泄漏）、提升开发效率。对于 ROS2 等现代化 C++ 项目，掌握这些新特性是必备的技能基础。
