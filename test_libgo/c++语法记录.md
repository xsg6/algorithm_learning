# 零碎知识点
## c++的基础类型
1. 普通类型，如int、char等等
2. 空类型，void,函数返回值，无类型指针（void* 可指向任意类型数据，需强制转换后使用）
3. 复合类型
    -指针类型
***特殊：函数指针 eg:int(*)(int)（函数指针，指向 “参数为 int、返回 int 的函数”）**
    -引用类型
    -数组类型
    -函数类型
## typedef与using的用法
主要是用于给一种类型取一种别名，主要针对那种比较复杂的类型，如函数指针
``` c++
eg:using IntVec = std::vector<int>; 用 IntVec 代替 std::vector<int>
```
## const关键字的各种用法（就近修饰，谁近谁就是常量）
主要看那边能被修饰，默认修饰左边，若左边元素不可以被修饰，则修饰右边，eg：char* const p，‘*’不能被修饰，所以修饰的是 p（指针），const得修饰实体（int、*这些都不是）
1. 核心作用是保护常量不被修改 eg:const int a=100
2. 难点：修饰指针
    第一种：const char* p，这是指向常量的指针，指针可变（指向其他东西），指向内容不可变
    第二种：char* const p，这是常量指针，指针不可变，只能指向一个地址，这个地址的内容可变
    第三种：const char* const p 这是指针和指针指向的变量都是常量，即都不可变
3. 难点：修饰引用&
``` c++
    eg:const exception& e
    这里的const修饰的是exception&,exception&代指exception类型的引用
```
4. 修饰类的成员函数
const 放在成员函数的参数列表后、函数体前（或声明后），表示该成员函数不会修改所属对象的任何非 mutable 成员变量，且只能调用其他 const 成员函数。
``` c++
    eg:int get_val() const;  // 声明：参数列表后加const
    定义时需保留const
```
## &关键字的各种用法（取地址符、引用和位与运算符）
1. 取地址符：作用与*刚好相反 eg：int num=100，int *p=&num，&num就是num的地址，p是指针，刚好指向地址
2. 引用：相当于原数据的别名，共享内存，常用于函数参数中，可以避免拷贝，同时可在函数内修改函数外内容
3. 位与运算符：二进制同'1'取'1'，否则取'0'
##size_t的作用
size_t是一种无符号整数类型，用于表述内存大小、数组长度等等
## 实例类的命名规则
1. 一般：小写_功能
2. 全局：g_小写_功能
3. 实例既有可能在栈（自动回收），也可能在堆（手动释放）堆：CLASS* class_my=new CLASS() 栈：CLASS class_my
## 类/结构体是否需要显示定义默认构造函数
``` c++
1. 需要无参创建类 eg：Student* arr = new Student[10]; 此时需要默认构造函数
2. 我不显示定义任何构造函数，则此时不需要显示定义默认构造函数，不过成员变量可能被初始化错误
3. 默认构造函数：没有参数 带参构造函数：有参数
4. eg：    Student(string n, int a, float s) : name(n), age(a), score(s) {}

    // 显式定义默认构造函数
    Student() : name("Unknown"), age(0), score(0.0f) {}
```
*** 一些c++新特性（ros2会用）***
## auto的用法
*** auto关键字是类型推导工具 ***
``` c++
1. 普通用法：auto x=100，推导基础类型
2. 推导复合类型：int x=100,auto& ref=x;//这里会推导成int&，但是&写出来
3. 推导STL容器/迭代器：用于推导迭代器很好用，auto it=arr.begin()等价于vector<int>::iterator it=arr.begin()
4. 推导函数返回值：ag：auto sum（）{}
5. 推导lambda表达式：
```
## lambda表达式
*** 匿名函数 ***
lambda 表达式（λ 表达式）是 C++11 引入的一种匿名函数（没有函数名的函数），可以就地定义、就地使用，核心用于简化代码（尤其是回调、算法参数、临时逻辑），避免编写独立的函数 / 函数对象。
基本结构：
``` c++
[capture](parameters) mutable -> return_type {
    // 函数体（执行逻辑）
};
```
1. [capture]	捕获列表：决定外部变量能否在 lambda 内使用（核心）	❌ 必选
2. (parameters)	参数列表：和普通函数的参数一致（类型、数量、默认值等）	✅ 可选
3. mutable	允许修改按值捕获的变量（默认按值捕获的变量是 const 的）	✅ 可选
4. -> return_type	返回值类型：编译器可自动推导（C++11 起），复杂场景需显式指定	✅ 可选
5. {}	函数体：执行逻辑	❌ 必选
*** 核心要点 ***
几种捕获方式，lambda可以访问外部作用域变量
1. 空捕获	[]	不捕获任何外部变量（仅能用参数和局部变量）
2. 按值捕获	[x, y]	捕获变量 x、y 的副本（lambda 内修改不影响外部）
3. 按引用捕获	[&x, &y]	捕获变量 x、y 的引用（lambda 内修改会影响外部）
4. 按值捕获所有	[=]	捕获所有外部变量的副本（默认 const，需 mutable 才能修改）
5. 按引用捕获所有	[&]	捕获所有外部变量的引用（修改会影响外部）
## 智能指针
使用条件：#include<memory>
智能指针本身在栈，指向（管理）的内容在堆上，因为只有堆上的内容才需要管理释放内存
作用：自动管理内存生命周期，避免内存泄漏、野指针、重复释放等问题
三种智能指针：
1. unique_ptr：独占指针，仅可有一个指针指向某个资源，离开作用域自动释放内存
2. shared_ptr: 带引用计数的共享智能指针，多个 shared_ptr 可指向同一资源，计数为 0 时自动释放资源。
3. weak_ptr:弱引用指针是 shared_ptr 的 “辅助工具”，指向 shared_ptr 管理的资源，但不增加引用计数，也不影响资源销毁，核心解决 shared_ptr 的循环引用问题。
## 函数包装器
#include<functional>





## 堆内存和栈内存
                                栈内存（Stack）	                                                堆内存（Heap）
内存大小	        固定且较小（通常几 MB，如 Linux 默认 8MB），由系统限制	    动态且极大（理论上受物理内存 + 虚拟内存限制），GB 级可用
分配 / 释放效率	     极快（仅需移动栈指针 esp/ebp，无系统调用）	                较慢（需操作系统查找空闲内存块，涉及malloc/free/new/delete系统调用）
内存碎片	        无碎片（栈是连续的 “后进先出” 结构，释放按顺序）	         易产生碎片（多次分配 / 释放不同大小的块，导致内存不连续）
生命周期	        与作用域绑定（如函数内的局部变量，函数结束即销毁）	         与作用域无关（手动分配后，直到free/delete才销毁，可跨函数 / 模块）
存储内容	        局部变量、函数参数、返回地址、寄存器备份等	                动态创建的对象、大数组、跨作用域的数据（如类的成员指针指向的内容）
访问方式	        直接访问（编译器知道栈变量的偏移地址）	                    间接访问（通过指针 / 引用，需解引用）
初始化规则	        未初始化的栈变量是 “垃圾值”（随机内存数据）	                未初始化的堆变量也是垃圾值，但new可指定初始化（如new int(10)）
线程安全性	        栈是线程私有（每个线程有独立栈，互不干扰）	                堆是进程共享（所有线程可访问，需加锁保证线程安全）
底层实现	        基于 “栈指针” 的连续内存区域，遵循 LIFO（后进先出）	        基于 “空闲内存链表” 的离散区域，由操作系统内存管理器管理

## c++宏定义的作用
1. 文本替换：仅做字符串替换，不理解 C++ 语法（比如变量、函数）
2. 预处理阶段执行：早于编译、链接，替换后代码才进入编译流程
3. 无类型安全：宏不检查数据类型，可能导致隐式类型转换错误
4. 作用域：从定义处到文件结束（可通过 #undef 手动终止）
*** 示例解释 ***
``` c++ 
1. 文本替换：#define MAX_CONN 10   
2. 宏函数：#define SWAP(a, b) do { auto temp = (a); (a) = (b); (b) = temp; } while(0) 需传变量，不能传字面量
3. 条件编译：#define DEBUG
4. 字符串化（#）与连接（##）操作符：#define TO_STRING(x) #x 将参数转为字符串
5. 简化重复代码：#define SQL_TRY_BEGIN try {
                #define SQL_TRY_END } catch (const exception& e) { cerr << "SQL 错误：" << e.what() << endl; }
6. 头文件保护：属于「条件编译」的延伸
    #ifndef SINGLE_PATTERN_H  // 1. 检查宏 SINGLE_PATTERN_H 是否未定义
    #define SINGLE_PATTERN_H  // 2. 若未定义，定义该宏（标记为“已包含”）
    #endif // SINGLE_PATTERN_H  // 4. 结束条件编译
```
## c++类的一些特性
1. 继承与多态
分三类：public/private/protected
*** 虚函数 ***
eg：virtual double area()const{return 0;} 重写 double area() const override{ return 3.14*r*r}
*** 纯虚函数 ***
eg: virtual double area() const = 0;包含纯虚函数的是抽象类，只能继承不能实现
## ->和.的区别
eg：auto comp_ptr = std::make_unique<SimpleComponent>(); 
    这句话的意思是创建智能（独占）指针指向SimpleComponent这个类的实例
    ->是和指针配套使用，.是和实例配套使用
    comp_ptr->chengyuan等价于(*comp_ptr).chengyuan
