## 动态规划

## 二分查找
## 堆排序
## 哈希表
1. 基本套路题：创建哈希表，遍历数组，将数组元素作为键，将元素下标作为值，存入哈希表中。
2. 不同的哈希容器：unordered_map、unordered_set(去重)
## 双指针
1.初始化：left=0,right=nums.size()-1
2. 循环：while(left<right)
3. 三指针：通常需要先固定一个，变成双指针问题
4. 移动指针：主要看题目的要求
## 滑动窗口（一般用来找子串/子序列）
1. 定长窗口：即窗口大小固定，窗口从左到右滑动，一般会维护一个固定大小的窗口，窗口内的元素就是我们要找的子串/子序列。右+1，左边也+1，保持窗口大小固定。
   初始化时，可以right=0,left=right-窗口长+1，当left<0时，窗口还没有形成，需要right++，直到left>=0时，窗口形成。
2. 变长窗口：即窗口大小不固定，窗口从左到右滑动
   变长窗口，通常是先一直动right，直到满足题目要求，然后再动left，直到不满足题目要求，然后再动right，直到满足题目要求，以此类推。(这里通常是一个最值问题)
3. 双端队列(deque): 模拟滑动窗口，窗口内的元素就是我们要找的子串/子序列。
   这里包含一个单调队列：  （保持队列内元素单调递增或递减）
   1. 单调递增队列：队头元素最小，队尾元素最大。
   2. 单调递减队列：队头元素最大，队尾元素最小。
   维护一个单调队列：
   3. 入队：当新元素比队尾元素大时，队尾元素出队，直到新元素比队尾元素小，或者队列为空时，新元素入队。
   4. 出队：当队头元素超出窗口大小时，队头元素出队。
   5. 队头元素：队头元素就是当前窗口的最大值/最小值。
   放到滑动窗口中：需要注意的就是left的问题，需要判断此时left的位置是不是队首，如果不是，则需要出队。
4. 单调栈：单调栈是一种特殊的栈，栈内元素是单调递增或递减的。
   1. 入栈：当新元素比栈顶元素大时，栈顶元素出栈，直到新元素比栈顶元素小，或者栈为空时，新元素入栈。
   2. 出栈：当栈顶元素超出窗口大小时，栈顶元素出栈。
   3. 栈顶元素：栈顶元素就是当前窗口的最大值/最小值。
## 子串c(与滑动窗口差不多)
前缀和：pre[j] = pre[i+1] - k/k=pre[i+1]-pre[j]（一般用来找子串最值）
后缀和/积：suf[j] = suf[i+1] - k/k=suf[i+1]-suf[j]（一般用来找子串最值）
## 子序列
1. 和子串的区别：子序列可以不连续，而子串必须连续。
## 一维数组问题
1. 原地哈希：将数组元素作为键，将元素下标作为值，存入数组中。
   1. 初始化：for(int i=0;i<nums.size();i++){nums[i]=i;}
   2. 遍历数组：for(int i=0;i<nums.size();i++){
      if(nums[i]!=nums[nums[i]-1]){
         swap(nums[i],nums[nums[i]-1]);
         i--;
      }
   }
   3. 检查：for(int i=0;i<nums.size();i++){
      if(nums[i]!=i+1){
         return false;
      }
   }
   return true;
## 回文串问题
1. 怎么判断一个字符串是不是回文串？
取left和right，从中心开始遍历两边，两者字符一直相等，则是字符串。
2. 中心可能为奇数，也可能为偶数，怎么统一？
数长度的中心：每个字符都是潜在中心 → 共 n 个
偶数长度的中心：每两个相邻字符之间的间隙 → 共 n-1 个
总中心数 = n + (n-1) = 2n-1 个 → 这就是循环条件 i < 2n-1 的原因
l = i/2 和 r = (i+1)/2 如何对应两种情况？
通过整数除法的特性，我们可以用 i 的奇偶性自动计算出对应的 l 和 r：

情况1：当 i 为偶数时（如 i=0,2,4...）

plainText
i=0: l=0/2=0, r=(0+1)/2=0 → l=r=0（单个中心，对应奇数长度）
i=2: l=2/2=1, r=(2+1)/2=1 → l=r=1（单个中心，对应奇数长度）
i=4: l=4/2=2, r=(4+1)/2=2 → l=r=2（单个中心，对应奇数长度）
此时 l 和 r 相等，对应奇数长度回文串的中心字符。

情况2：当 i 为奇数时（如 i=1,3,5...）

plainText
i=1: l=1/2=0, r=(1+1)/2=1 → l=0, r=1（两个中心，对应偶数长度）
i=3: l=3/2=1, r=(3+1)/2=2 → l=1, r=2（两个中心，对应偶数长度）
i=5: l=5/2=2, r=(5+1)/2=3 → l=2, r=3（两个中心，对应偶数长度）
# 动态规划
1. 找出状态转移方程
2. 递归+记忆化
3. 如果是二维dp问题就是二维数组
4. 优化成1维数组
5. 转成递推(迭代)
# 矩阵问题
1. 移动：定义上下左右4方向数组
``` c++
const int dirs[4][2]={{-1,0},{1,0},{0,1},{0,-1}};
```
2. 通常需要创建一个二维数组或者两个一维数组(分别记录行和列)，用来记录某个位置的访问情况