# 算法学习记录
## 查找
1. 二分查找
*** 左闭右闭与左闭右开 ***
``` c++
区别：初始化时右闭是right=size，右开是right=size-1
      while时右闭是(left<=right)，右开时是(left < right)
      原因是右开时，left==right时，[left,right)没有意义
```
## 排序
1. 快速排序(递归实现)
2. 堆排序
3. 归并排序（递归实现）
## 回溯
回溯模式：选+递归+不选（回溯）+剪枝
## 矩阵
1.要求：一般都是要求常量空间
2.方法：标记、缩小循环边界
## 栈
*** 核心要点 ***
什么时候入栈/出栈，要把什么东西入栈/出栈
1. 括号匹配
## 堆
堆排序的核心是利用堆这种完全二叉树的数据结构的特性，将待排序数组转化为堆结构，通过反复提取堆顶元素
*** 核心要点 ***
什么是最大堆/最小堆
1. 大顶堆：每个父节点的值 ≥ 其子节点的值
2. 小顶堆：每个父节点的值 ≤ 其子节点的值
## 单调栈/队列
单调栈的作用是：用 O(n) 的时间得知所有位置两边第一个比他大(或小)的数的位置。
核心：从栈顶到栈底单调递增/减，即为单调增/减栈
## 贪心算法
主要要维护一个目标值，配合遍历
*** 难点 ***
## 动态规划
不重复做相同的事，把复杂问题拆成简单小问题，用小问题的答案推大问题的答案
核心：
1. 记住之前算过的答案（避免重复计算）
2. 从简单的小问题答案，推导出复杂大问题的答案。
三要素：
1. 状态：要求解的东西
2. 状态转移方程：大状态的答案 = 小状态答案的组合规则。
3. 初始条件：给的初始数据
两种实现方式：
1. 自底向上：一步步拼凑
2. 自顶向下：递归+记忆
技巧：dp数组 dp[n]和dp[n-1]的关系
***背包问题***
1. 0/1背包
物品只能选一次
*** 状态转移方程 ***
dp[j] = max(dp[j], dp[j - w[i]] + v[i])
这里的dp[j]值的是容量为j时的最大价值
遍历方向：从后往前（原因：倒序能避免被物品被多次选择）
2. 完全背包
物品可以无限选
*** 状态转移方程 ***
dp[j] = max(dp[j], dp[j - w[i]] + v[i])
区别：遍历方向：从前往后（因为可以重复选）
## 位运算
1. &：按位与，同1为1，否则为0
2. |：按位或，同0为0，否则为1
3. ^：按位异或，不同为1，同为0
4. ~：按位取反，0变1，1变0
5. <<:左移n位，右侧补0，高位溢出舍弃
6. >>:右移n位，正数左侧补0，负数
## 双指针
基本流程：
1.左指针和右指针
循环：while(left<right){
      每个题的循环条件/目标不一样
      left++/right--
}
## 滑动窗口
也是一种双指针，维护一个动态窗口
***核心思想***
右进左出，而且是先进后出，比如需要长度为3，那么长度应该是3-2-3-2这样变动
把枚举所有子数组 / 子串的暴力思路，优化为「窗口滑动」：
1. 用右指针扩展窗口，直到窗口内元素满足 / 不满足目标条件；
2. 用左指针收缩窗口，直到窗口内元素重新满足 / 不满足目标条件；
3. 滑动过程中实时更新结果（如最长窗口长度、最短窗口长度）。
*** 定长窗口 ***
核心：同时加右减左（达到所需条件后，如长度/数值和），注意右边界也是从0开始的，它需要把每一个值先放进来，达到长度后，进行判断，然后缩小左边界（右移左边界），继续判断
*** 不定长窗口 ***
核心：也是加右减左，但是不是同时，是先一直加右到要求，然后开始一直减左达到要求（这里可以是不重复，最小值等等），这里窗口长度可以减为0
## 前缀和
典型题目：
## 递归
*** 本质是一个调用栈，return是为了能够正常出栈 ***
通常由两个部分组成：
1. 递归结束条件
   eg：if（root==nullptr）return 0;
2. 自我调用
   eg:getnode(root->left) getnode(root->right)
3. 返回值
   return root
*** 关键：明白递归是个什么过程 ***
    递归是自底向上的，首先会一直走直到退出，还有应该关键点，就是要有时候要接受下面的返回值，这样有时候才能做到提前结束递归的问题，避免返回值被覆盖
## 链表的指向变化
这个感觉有点绕，需要认真学习一下
首先由于链表需要返回他的头节点，所以往往需要一个哑节点
初始化：ListNode* dum= new ListNode(0,head),创建一个值为0，指向头节点的哑节点
同时，会再用一个指针指向哑节点，因为要保持哑节点始终指向头节点 node0=dum
*** 关键点 ***
1. node0此时可以看成dum的替身，我使用node0->next=其他节点时，dum->next会同步更新
2. 而且我们改哑节点next节点的指向时，哑节点不受影响
3. 当node0=其他节点时，node0->next就不会同步被影响了

