# 算法学习记录
## 查找
1. 二分查找
*** 左闭右闭与左闭右开 ***
``` c++
区别：初始化时右闭是right=size，右开是right=size-1
      while时右闭是(left<=right)，右开时是(left < right)
      原因是右开时，left==right时，[left,right)没有意义
```
## 排序
1. 快速排序(递归实现)
2. 堆排序
3. 归并排序（递归实现）
## 回溯
回溯模式：选+递归+不选（回溯）+剪枝
关键套路：
eg: 
```c++
void dfs(vector<vector<int>>&res,vector<int>& candidates,int target,vector<int>& path,int k){
        if(target<0){
            return;
        }
        if(target==0){
            res.emplace_back(path);
            return ;
        }
        for(int i=k;i<candidates.size();i++){
            path.push_back(candidates[i]);
            target-=candidates[i];
            
            dfs(res,candidates,target,path,i);
            path.pop_back();
            target+=candidates[i];
        }
        
    }
```
主要关注path的变化，还有什么时候进行dfs，dfs(res,candidates,target,path,i);关键在i的变化，因为要避免重复选择，所以i从k开始，有时只选一次，会从k+1开始
还有path.pop_back();这里是回溯，也叫恢复现场
## 矩阵
1.要求：一般都是要求常量空间
2.方法：标记、缩小循环边界
## 栈
*** 核心要点 ***
什么时候入栈/出栈，要把什么东西入栈/出栈
1. 括号匹配
## 堆
堆排序的核心是利用堆这种完全二叉树的数据结构的特性，将待排序数组转化为堆结构，通过反复提取堆顶元素
1. 堆化：将一个数组转化为堆结构，从最后一个非叶子节点开始，从下往上堆化
   最后一个非叶子节点：n / 2 - 1
   推导：
   1. 最后一个非叶子节点的左子节点：2 * i + 1=n-1
   2. 最后一个非叶子节点的右子节点：2 * i + 2=n-1
    得i=(n-1-1)/2=(n-2)/2
2. 构建大(小)顶堆
*** 核心要点 ***
什么是最大堆/最小堆
1. 大顶堆：每个父节点的值 ≥ 其子节点的值
2. 小顶堆：每个父节点的值 ≤ 其子节点的值
## 单调栈/队列
单调栈的作用是：用 O(n) 的时间得知所有位置两边第一个比他大(或小)的数的位置。
核心：从栈顶到栈底单调递增/减，即为单调增/减栈
```  c++
eg:         int h=heights[i];
            while(!s.empty()&&heights[s.top()]>=h){
                s.pop();
            }
            if(!s.empty()){
                left[i]=s.top();
            }
            s.push(i);
```
## 贪心算法
主要要维护一个目标值，配合遍历
*** 难点 ***
## 动态规划
不重复做相同的事，把复杂问题拆成简单小问题，用小问题的答案推大问题的答案
首先要做的就是推导状态转移方程
核心：
1. 记住之前算过的答案（避免重复计算）
2. 从简单的小问题答案，推导出复杂大问题的答案。
三要素：
1. 状态：要求解的东西
2. 状态转移方程：大状态的答案 = 小状态答案的组合规则。
3. 初始条件：给的初始数据
两种实现方式：
1. 自底向上：一步步拼凑（递推，也即动态规划）
2. 自顶向下：递归+记忆
技巧：dp数组 dp[n]和dp[n-1]的关系
*** 递归+记忆化搜索 ***
会有一个记忆化数组 memo[n]，用于存储已经计算过的状态答案。
***背包问题***
1. 0/1背包
物品只能选一次
*** 状态转移方程 ***
dp[j] = max(dp[j], dp[j - w[i]] + v[i])
这里的dp[j]值的是容量为j时的最大价值
遍历方向：从后往前（原因：倒序能避免被物品被多次选择）
1. 完全背包
物品可以无限选
*** 状态转移方程 ***
dp[j] = max(dp[j], dp[j - w[i]] + v[i])
区别：遍历方向：从前往后（因为可以重复选）
## 位运算
1. &：按位与，同1为1，否则为0
2. |：按位或，同0为0，否则为1
3. ^：按位异或，不同为1，同为0
4. ~：按位取反，0变1，1变0
5. <<:左移n位，右侧补0，高位溢出舍弃
6. >>:右移n位，正数左侧补0，负数
## 双指针
基本流程：
1.左指针和右指针
循环：while(left<right){
      每个题的循环条件/目标不一样
      left++/right--
}
## 滑动窗口
也是一种双指针，维护一个动态窗口
***核心思想***
右进左出，而且是先进后出，比如需要长度为3，那么长度应该是3-2-3-2这样变动
把枚举所有子数组 / 子串的暴力思路，优化为「窗口滑动」：
1. 用右指针扩展窗口，直到窗口内元素满足 / 不满足目标条件；
2. 用左指针收缩窗口，直到窗口内元素重新满足 / 不满足目标条件；
3. 滑动过程中实时更新结果（如最长窗口长度、最短窗口长度）。
*** 定长窗口 ***
核心：同时加右减左（达到所需条件后，如长度/数值和），注意右边界也是从0开始的，它需要把每一个值先放进来，达到长度后，进行判断，然后缩小左边界（右移左边界），继续判断
*** 不定长窗口 ***
核心：也是加右减左，但是不是同时，是先一直加右到要求，然后开始一直减左达到要求（这里可以是不重复，最小值等等），这里窗口长度可以减为0
## 前缀和
*** 求多个区间和 ***
前缀和（Prefix Sum） 是一种预处理数组的技巧，核心是构建一个新数组 pre_sum，其中 pre_sum[i] 表示原数组 nums 中前 i 个元素的累加和
定义方式	公式	示例（nums = [1,2,3,4]）
方式 1（前 i 个元素和）	pre_sum[0] = 0；pre_sum[i] = pre_sum[i-1] + nums[i-1]	pre_sum = [0,1,3,6,10]
pre_sum[i] = pre_sum[i-1] + nums[i-1]; // 核心递推公式
典型题目：
## 递归(dfs)
*** 本质是一个调用栈，return是为了能够正常出栈 ***
通常由两个部分组成：
1. 递归结束条件
   eg：if（root==nullptr）return 0;
2. 自我调用
   eg:getnode(root->left) getnode(root->right)
3. 返回值
   return root
*** 关键：明白递归是个什么过程 ***
    递归是自底向上的，首先会一直走直到退出，还有应该关键点，就是要有时候要接受下面的返回值，这样有时候才能做到提前结束递归的问题，避免返回值被覆盖
*** 递的过程 ***
将问题不断的细化成更小的部分（与分治类似）
*** 归的过程 ***
找到问题的出口以及需要将什么返回给上一级
## 链表的指向变化
这个感觉有点绕，需要认真学习一下
首先由于链表需要返回他的头节点，所以往往需要一个哑节点
初始化：ListNode* dum= new ListNode(0,head),创建一个值为0，指向头节点的哑节点
同时，会再用一个指针指向哑节点，因为要保持哑节点始终指向头节点 node0=dum
*** 关键点 ***
1. node0此时可以看成dum的替身，我使用node0->next=其他节点时，dum->next会同步更新
2. 而且我们改哑节点next节点的指向时，哑节点不受影响
3. 当node0=其他节点时，node0->next就不会同步被影响了
## 二叉树
一些概念：
1. 链：从下面的某个节点（不一定是叶子）到当前节点的路径。
所以最大链值：max(左子树最大值，右子树最大值)+当前节点值
1. 二叉数的直径：等价于由两条（或者一条）链拼成的路径


