## 当前多线程学习
目前框架：单例线程池，支持任务提交和结果获取。
下一步，集成mysql测试多连接的执行逻辑
## 一些知识
1. 什么是超线程：超线程技术，它允许每个物理核心（Core）同时运行两个逻辑线程（Thread）。这意味着每个物理核心可以在相同的时间内执行两个独立的线程，从而提高了处理器的利用率。
2. std::thread::hardware_concurrency()：返回当前系统支持的最大并发线程数。
3. 同步和异步
   同步：不是“马上给结果”，而是“调用者必须等待结果产生”即使操作需要很长时间（如网络请求、文件读写），调用者也会阻塞直到操作完成，例如：直接调用read()函数从文件读取数据，程序会暂停直到数据读取完成
   异步：不是“过一段时间给结果”，而是“调用者不需要等待结果，可以先做其他事”，操作在后台执行，完成后通过约定的机制通知调用者例如：使用异步IO读取文件，程序可以继续执行其他代码，当数据准备好后通过回调函数处理
4. 原子操作
   原子操作是指在多线程环境下，对共享数据进行的操作，能够确保在任何时刻只有一个线程在执行，从而避免了竞态条件（Race Condition）的发生。
5. 上下文切换：
    切换类型	主要切换内容	      开销大小	    典型耗时（参考）
    模式切换	特权级别+少量寄存器	    最小	    几纳秒~几十纳秒
    线程切换	线程私有上下文	        中等	    几十纳秒~几百纳秒
    进程切换	完整进程上下文+内存映射	 最大	     几百纳秒~几微秒

## packaged_task
是 C++11 引入的用于将函数或可调用对象包装成一个任务的类模板。它可以将一个异步操作封装成一个可调用对象，方便在其他线程中执行。
核心功能
1. 封装任务：将可调用对象包装成一个可执行任务
2. 异步结果获取：通过std::future可以在任务执行完成后获取其返回值
3. 类型安全：模板参数指定任务的返回类型和参数类型
## future
是 C++11 引入的用于异步编程的核心组件，它代表了一个尚未完成的异步操作的结果。简单来说，它是一个"未来"会产生结果的占位符。
## 几种锁（可以是线程锁，也可以是进程锁）
1. std::mutex：互斥锁，用于保护共享资源，确保在任意时刻只有一个线程可以访问该资源。
2. std::timed_mutex：定时互斥锁，在 std::mutex 的基础上添加了超时机制，用于在指定时间内尝试获取锁，避免死锁。
3. std::recursive_mutex：递归互斥锁，允许同一个线程对互斥锁进行递归加锁，而不会导致死锁。
4. std::shared_mutex（C++17 引入）：共享互斥锁，允许多个线程同时读取共享资源，但在写入时互斥。
5. std::lock_guard：锁守卫，用于在作用域内自动加锁和解锁互斥锁，避免忘记解锁导致死锁。
6. std::unique_lock：唯一锁，与 std::lock_guard 类似，但提供了更多的灵活性，如延迟加锁、尝试加锁等。
7. std::shared_lock（C++17 引入）：共享锁，用于保护共享资源的读取操作，允许多个线程同时加锁。
